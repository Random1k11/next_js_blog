{"pageProps":{"posts":[{"id":1,"title":"Python | Комбинирование асинхронного кода с потоками и процессами","text":"Асинхронность в Python набирает популярность многие библиотеки переписываются на асинхронный код. Но даже синхронный код можно запускать таким способом, чтобы вся программа не останавливалась, а продолжала работать.\r\nДля этого в Python есть `executor` из `concurrent.futures`. Это может быть как `ThreadPoolExecutor` для запуска в отдельном потоке, так и `ProcessPoolExecutor` для запуска в отдельном процессе.\r\n\r\n&nbsp;\r\n### Запуск в отдельном потоке\r\n\r\nУ цикла событий есть метод `run_in_executor()` которй принимает экземпляр `concurrent.futures.Executor`. Он принимает `executor`, функцию для запуска и её параметры.\r\n```python\r\nimport asyncio\r\nimport concurrent.futures\r\nimport logging\r\nimport sys\r\nimport time\r\n\r\n\r\ndef blocks(n):\r\n    log = logging.getLogger('blocks({})'.format(n))\r\n    log.info('running')\r\n    time.sleep(0.1)\r\n    log.info('done')\r\n    return n ** 2\r\n\r\n\r\nasync def run_blocking_tasks(executor):\r\n    log = logging.getLogger('run_blocking_tasks')\r\n    log.info('starting')\r\n\r\n    log.info('creating executor tasks')\r\n    loop = asyncio.get_event_loop()\r\n    blocking_tasks = [\r\n        loop.run_in_executor(executor, blocks, i)\r\n        for i in range(6)\r\n    ]\r\n    log.info('waiting for executor tasks')\r\n    completed, pending = await asyncio.wait(blocking_tasks)\r\n    results = [t.result() for t in completed]\r\n    log.info('results: {!r}'.format(results))\r\n\r\n    log.info('exiting')\r\n\r\n\r\nif __name__ == '__main__':\r\n    # Configure logging to show the name of the thread\r\n    # where the log message originates.\r\n    logging.basicConfig(\r\n        level=logging.INFO,\r\n        format='%(threadName)10s %(name)18s: %(message)s',\r\n        stream=sys.stderr,\r\n    )\r\n\r\n    # Create a limited thread pool.\r\n    executor = concurrent.futures.ThreadPoolExecutor(\r\n        max_workers=3,\r\n    )\r\n\r\n    event_loop = asyncio.get_event_loop()\r\n    try:\r\n        event_loop.run_until_complete(\r\n            run_blocking_tasks(executor)\r\n        )\r\n    finally:\r\n        event_loop.close()\r\n```\r\n&nbsp;\r\n#### Вывод:\r\n&nbsp;\r\n\r\n\r\n```bash\r\nMainThread run_blocking_tasks: Старт\r\nMainThread run_blocking_tasks: Создаем задачи\r\nThreadPoolExecutor-0_0      block_task(0): Запущен\r\nThreadPoolExecutor-0_1      block_task(1): Запущен\r\nThreadPoolExecutor-0_2      block_task(2): Запущен\r\nMainThread run_blocking_tasks: Ожидание выполнения задач\r\nThreadPoolExecutor-0_0      block_task(0): Сделано\r\nThreadPoolExecutor-0_1      block_task(1): Сделано\r\nThreadPoolExecutor-0_0      block_task(3): Запущен\r\nThreadPoolExecutor-0_1      block_task(4): Запущен\r\nThreadPoolExecutor-0_2      block_task(2): Сделано\r\nThreadPoolExecutor-0_2      block_task(5): Запущен\r\nThreadPoolExecutor-0_1      block_task(4): Сделано\r\nThreadPoolExecutor-0_1      block_task(6): Запущен\r\nThreadPoolExecutor-0_0      block_task(3): Сделано\r\nThreadPoolExecutor-0_0      block_task(7): Запущен\r\nThreadPoolExecutor-0_2      block_task(5): Сделано\r\nThreadPoolExecutor-0_2      block_task(8): Запущен\r\nThreadPoolExecutor-0_1      block_task(6): Сделано\r\nThreadPoolExecutor-0_1      block_task(9): Запущен\r\nThreadPoolExecutor-0_0      block_task(7): Сделано\r\nThreadPoolExecutor-0_2      block_task(8): Сделано\r\nThreadPoolExecutor-0_1      block_task(9): Сделано\r\nMainThread run_blocking_tasks: Результат: [25, 4, 36, 81, 9, 49, 0, 16, 64, 1]\r\nMainThread run_blocking_tasks: Конец\r\ndima@dima-rus:~/Desktop/learning/asyncio_learn/samples$ clear\r\ndima@dima-rus:~/Desktop/learning/asyncio_learn/samples$ python3 thread_executor.py \r\nMainThread run_blocking_tasks: Старт\r\nMainThread run_blocking_tasks: Создаем задачи\r\nThreadPoolExecutor-0_0      block_task(0): Запущен\r\nThreadPoolExecutor-0_1      block_task(1): Запущен\r\nThreadPoolExecutor-0_2      block_task(2): Запущен\r\nMainThread run_blocking_tasks: Ожидание выполнения задач\r\nThreadPoolExecutor-0_0      block_task(0): Сделано\r\nThreadPoolExecutor-0_0      block_task(3): Запущен\r\nThreadPoolExecutor-0_1      block_task(1): Сделано\r\nThreadPoolExecutor-0_1      block_task(4): Запущен\r\nThreadPoolExecutor-0_2      block_task(2): Сделано\r\nThreadPoolExecutor-0_2      block_task(5): Запущен\r\nThreadPoolExecutor-0_0      block_task(3): Сделано\r\nThreadPoolExecutor-0_0      block_task(6): Запущен\r\nThreadPoolExecutor-0_1      block_task(4): Сделано\r\nThreadPoolExecutor-0_1      block_task(7): Запущен\r\nThreadPoolExecutor-0_2      block_task(5): Сделано\r\nThreadPoolExecutor-0_2      block_task(8): Запущен\r\nThreadPoolExecutor-0_0      block_task(6): Сделано\r\nThreadPoolExecutor-0_0      block_task(9): Запущен\r\nThreadPoolExecutor-0_1      block_task(7): Сделано\r\nThreadPoolExecutor-0_2      block_task(8): Сделано\r\nThreadPoolExecutor-0_0      block_task(9): Сделано\r\nMainThread run_blocking_tasks: Результат: [25, 4, 36, 81, 9, 49, 0, 16, 64, 1]\r\nMainThread run_blocking_tasks: Конец\r\n\r\n```\r\n&nbsp;\r\n### Запуск в отдельном процессе\r\n\r\nЗдесь `ThreadPoolExecutor` заменяется на `ProcessPoolExecutor`. И происходит запуск нескольких процессов на кождом ядре т.е. работает несколько интерпретаторов Python. В этом случае блокирующие задачи действительно выполняются параллельно, в отличие от потоков где они переключаются на уровне операционной системы. Это вызвано ограничением `GIL`.\r\n\r\nТеперь вы можете эффективно использовать блокирующий код в асинхронном приложении.","image":"http://d-rusanov.ru/media/thread_python.png","active":true,"updated_at":"2020-12-22T13:51:20.042933+03:00","created_at":"2020-12-18T00:09:20.919858+03:00","categories":[]},{"id":2,"title":"test","text":"test","image":"http://d-rusanov.ru/media/carbon4.png","active":true,"updated_at":"2020-12-21T21:59:24.637560+03:00","created_at":"2020-12-21T21:59:24.644192+03:00","categories":[]}]},"__N_SSG":true}