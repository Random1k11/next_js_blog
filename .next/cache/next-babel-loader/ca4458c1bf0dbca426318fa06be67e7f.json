{"ast":null,"code":"var __jsx = React.createElement;\nimport React, { useState, useEffect } from 'react';\nimport ReactPaginate from 'react-paginate';\nimport Router, { withRouter } from 'next/router';\nimport ReactMarkdown from 'react-markdown';\nimport { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';\nimport Main from '../components/layout/main/Main';\nimport PostPreview from '../components/postPreview/PostPreview';\nimport API_URL from \"../utils/http-utils\";\nimport blogConfig from \"../blogConfig\";\n\nconst Posts = props => {\n  const posts = props.posts;\n  const {\n    0: isLoading,\n    1: setLoading\n  } = useState(false); //State for the loading indicator\n\n  const startLoading = () => setLoading(true);\n\n  const stopLoading = () => setLoading(false);\n\n  useEffect(() => {\n    //After the component is mounted set router event handlers\n    Router.events.on('routeChangeStart', startLoading);\n    Router.events.on('routeChangeComplete', stopLoading);\n    return () => {\n      Router.events.off('routeChangeStart', startLoading);\n      Router.events.off('routeChangeComplete', stopLoading);\n    };\n  }, []);\n\n  const paginationHandler = page => {\n    const currentPath = props.router.pathname;\n    const currentQuery = props.router.query;\n    currentQuery.page = page.selected + 1;\n    props.router.push({\n      pathname: currentPath,\n      query: currentQuery\n    });\n  };\n\n  const renderers = {\n    code: ({\n      language,\n      value\n    }) => {\n      return __jsx(SyntaxHighlighter, {\n        language: language,\n        children: value\n      });\n    }\n  };\n  let content;\n\n  __jsx(\"div\", {\n    style: {\n      display: 'flex',\n      justifyContent: 'center'\n    }\n  }, __jsx(\"div\", null, \"centered content\"));\n\n  if (isLoading) content = __jsx(\"div\", {\n    style: {\n      display: 'flex',\n      justifyContent: 'center'\n    }\n  }, __jsx(\"div\", null, \"Loading...\"));else {\n    //Generating posts list\n    content = (posts || []).map(post => __jsx(PostPreview, {\n      key: post.slug,\n      slug: post.slug,\n      title: post.title,\n      previewText: __jsx(ReactMarkdown, {\n        renderers: renderers\n      }, post.text.slice(0, 500)),\n      previewImage: post.image,\n      lastEdit: new Date(post.updated_at).toDateString()\n    }));\n  }\n  let paginate = null;\n\n  if (props.totalCount >= props.perPage) {\n    paginate = __jsx(\"div\", {\n      className: \"paginate-container\"\n    }, __jsx(ReactPaginate, {\n      key: props.currentPage,\n      previousLabel: 'previous',\n      nextLabel: 'next',\n      breakLabel: '...',\n      breakClassName: 'break-me',\n      activeClassName: 'active',\n      containerClassName: 'pagination',\n      subContainerClassName: 'pages pagination',\n      initialPage: props.currentPage - 1,\n      pageCount: props.pageCount,\n      marginPagesDisplayed: 2,\n      pageRangeDisplayed: 5,\n      onPageChange: paginationHandler\n    }));\n  }\n\n  return __jsx(\"div\", {\n    className: \"container\"\n  }, __jsx(Main, null, __jsx(\"div\", {\n    className: \"posts\"\n  }, content, paginate)));\n}; //Fetching posts in get Intial Props to make the app seo friendly\n\n\nPosts.getInitialProps = async ({\n  query\n}) => {\n  const currentPage = query.page;\n  const perPage = blogConfig.pagination.amountPostsOnPage;\n  let pageOffset;\n\n  if (currentPage === '0' || currentPage === '1' || currentPage == null) {\n    pageOffset = 0;\n  } else {\n    pageOffset = parseInt(currentPage) * perPage - perPage;\n  }\n\n  const url = API_URL + `?limit=${perPage}` + `&offset=${pageOffset}`;\n  const res = await fetch(url);\n  const posts = await res.json();\n  const pageCount = posts.count / perPage;\n  return {\n    totalCount: posts.count,\n    pageCount: pageCount,\n    currentPage: currentPage,\n    perPage: perPage,\n    posts: posts.results\n  };\n};\n\nexport default withRouter(Posts);","map":null,"metadata":{},"sourceType":"module"}